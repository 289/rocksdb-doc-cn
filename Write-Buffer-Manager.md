写缓冲管理器帮助用户控制多个列族及DB实例中的memtables的总的内存使用。通过这个，用户可以实现：

- 尝试限制多个列族和DB实例总的memtable使用量到一定的阈值下。
- 允许memtable使用块缓存

写缓冲管理器跟rate_limiter和sst_file_manager很相似。用户创建一个写缓冲管理器对象，然后把他传递给所有你希望控制总内存空间的列族和DB。参考write_buffer_manager.h中的注释来了解如何使用。

# 限制memtalbe的总内存

一个内存显示量会在创建写缓冲管理器的时候被给出。RocksDB会尝试把总内存使用量控制在这个限制之下。

在5.6以及更高的版本，当你在导入数据的时候，如果总的可变memtable的大小超过限制的90%，对应列族的DB会触发一次落盘。如果实际的内存已经超过限制，即使总的可变memtable大小少于限制的90%，也会触发一次激进的落盘操作。在5.6版本之前，如果总的可变memtable超过限制，触发一次落盘。

在5.6以及更高的版本，所有在同一个管理器分配的内存都被计算入内，即使这些内存不是被memtable使用。在更早的版本，内存的计算是按照memtable实际使用的量来计算的。

# 允许memtable使用块缓存

从5.6版本之后，用户可以配置RocksDB来消费memtable使用的内存，给块缓存使用。这个不管是否打开memtable内存限制，都会发生。

在大多数情况下，块缓存中实际使用的块，与块缓存中的数据块比起来，只是非常小的一个比例，所以当用户打开这个功能，块缓存容量会同时被块缓存和memtable使用。如果用户同时还打开了cache_index_and_filter_blocks，那么RocksDB中三个主要的内存使用都会被一个容量覆盖。

这里解释它是怎么实现的。没分配给memtable 1MB的内存，WriteBufferManager会放一个假的1MB项到块缓存，这样块缓存就可以正确地追踪实际使用的大小，然后淘汰块来获取必要的空间。对于memtable缩减的时候使用的空间，WriteBufferManager不会立即删除假的缓存块，他会在内存使用量显著下降的时候，缓慢地移除他们。这是因为memtable的内存使用总是在浮动的，我们不希望经常去打扰块缓存。

打开这个功能的方法：

- 把你希望使用的块缓存传递给你即将使用的WriteBufferManager。
- 还是要把你希望memtable使用的最大内存传递给WriteBufferManager。
- 把数据块缓存和memtable内存的总大小，设置为块缓存的容量

